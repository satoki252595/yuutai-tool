import express from 'express';
import cors from 'cors';
import { Database } from './database.js';
import { YahooFinanceService } from './yahooFinance.js';
import { RSICalculator } from './rsiCalculator.js';

const app = express();
const PORT = process.env.PORT || 5001;

app.use(cors());
app.use(express.json());

const db = new Database();
const yahooFinance = new YahooFinanceService();
const rsiCalculator = new RSICalculator();

// „É°„É¢„É™„Ç≠„É£„ÉÉ„Ç∑„É•„ÅÆÂÆüË£Ö
const stockCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5ÂàÜÈñì„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•

// „Ç≠„É£„ÉÉ„Ç∑„É•„Éü„Éâ„É´„Ç¶„Çß„Ç¢
const cacheMiddleware = (req, res, next) => {
  const key = req.originalUrl;
  const cached = stockCache.get(key);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    console.log(`üì¶ „Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„Éà: ${key}`);
    return res.json(cached.data);
  }
  
  // „Ç™„É™„Ç∏„Éä„É´„ÅÆjsonÈñ¢Êï∞„Çí‰øùÂ≠ò
  const originalJson = res.json;
  res.json = function(data) {
    stockCache.set(key, {
      data,
      timestamp: Date.now()
    });
    console.log(`üíæ „Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠ò: ${key}`);
    originalJson.call(this, data);
  };
  
  next();
};

// ÂÑ™ÂæÖÂà©Âõû„Çä„ÉªÁ∑èÂêàÂà©Âõû„ÇäË®àÁÆó
function calculateYields(stock, benefits) {
  if (!stock.price || stock.price === 0) {
    return { dividendYield: 0, benefitYield: 0, totalYield: 0 };
  }
  
  const dividendYield = stock.dividend_yield || 0;
  
  // ÂÑ™ÂæÖÂà©Âõû„ÇäË®àÁÆó: ÂÑ™ÂæÖÈáëÈä≠‰æ°ÂÄ§ √∑ (ÂÑ™ÂæÖÂøÖË¶ÅÊ†™ÂºèÊï∞ √ó Ê†™‰æ°) √ó 100
  let benefitYield = 0;
  if (benefits.length > 0) {
    // ÊúÄÂ∞èÊ†™ÂºèÊï∞„Åß„ÅÆÂÑ™ÂæÖ„ÇíÂü∫Ê∫ñ„Å´Ë®àÁÆó
    const minSharesBenefit = benefits.reduce((min, benefit) => {
      return (benefit.min_shares || 100) < (min.min_shares || 100) ? benefit : min;
    });
    
    const requiredShares = minSharesBenefit.min_shares || 100;
    const investmentAmount = stock.price * requiredShares;
    
    // Âπ¥Èñì„ÅÆÂÑ™ÂæÖ‰æ°ÂÄ§„ÇíË®àÁÆó
    // Âêå„ÅòÊ†™ÂºèÊï∞Ë¶Å‰ª∂„ÅÆÂÑ™ÂæÖ„Çí„Ç∞„É´„Éº„ÉóÂåñ
    const shareGroups = {};
    benefits.forEach(benefit => {
      const shares = benefit.min_shares || 100;
      if (!shareGroups[shares]) {
        shareGroups[shares] = [];
      }
      shareGroups[shares].push(benefit);
    });
    
    // ÊúÄÂ∞èÊ†™ÂºèÊï∞„Ç∞„É´„Éº„Éó„ÅÆÂÑ™ÂæÖ‰æ°ÂÄ§„ÇíË®àÁÆó
    const minSharesGroup = shareGroups[requiredShares] || [];
    let annualBenefitValue = 0;
    
    if (minSharesGroup.length > 0) {
      // Ê®©Âà©Êúà„Åî„Å®„Å´„Ç∞„É´„Éº„ÉóÂåñ
      const monthlyBenefits = {};
      minSharesGroup.forEach(benefit => {
        const month = benefit.ex_rights_month || 3;
        monthlyBenefits[month] = benefit;
      });
      
      // ÂêÑÊ®©Âà©Êúà„ÅÆ‰æ°ÂÄ§„ÇíÂêàË®à
      annualBenefitValue = Object.values(monthlyBenefits).reduce((sum, benefit) => {
        return sum + (benefit.monetary_value || 0);
      }, 0);
    }
    
    benefitYield = (annualBenefitValue / investmentAmount) * 100;
  }
  
  const totalYield = dividendYield + benefitYield;
  
  return {
    dividendYield: Math.round(dividendYield * 100) / 100,
    benefitYield: Math.round(benefitYield * 100) / 100,
    totalYield: Math.round(totalYield * 100) / 100
  };
}

// Ê†™Âºè‰∏ÄË¶ßÂèñÂæóÔºà„Ç≠„É£„ÉÉ„Ç∑„É•Ê©üËÉΩ‰ªò„ÅçÔºâ
app.get('/api/stocks', cacheMiddleware, async (req, res) => {
  try {
    const { 
      search, 
      sortBy = 'totalYield', 
      sortOrder = 'desc',
      benefitType,
      rightsMonth,
      rsiFilter,
      longTermHolding
    } = req.query;
    
    const stocks = await db.getStocksWithBenefits(search);
    
    // ÂêÑÈäòÊüÑ„ÅÆË©≥Á¥∞ÊÉÖÂ†±„ÇíÂèñÂæó
    const stockCodes = stocks.map(s => s.code);
    console.log(`Calculating RSI for ${stockCodes.length} stocks...`);
    const rsiData = await rsiCalculator.calculateMultipleRSI(stockCodes);
    console.log(`RSI calculation complete. Sample:`, Object.keys(rsiData).slice(0, 3).map(code => ({ code, rsi14: rsiData[code]?.rsi14 })));
    
    let stocksWithDetails = await Promise.all(stocks.map(async (stock) => {
      const benefits = await db.getBenefitsByStockCode(stock.code);
      const yields = calculateYields(stock, benefits);
      
      // ÂÑ™ÂæÖ„Ç∏„É£„É≥„É´„ÇíÂàÜÈ°û
      const benefitGenres = [...new Set(benefits.map(b => b.benefit_type).filter(Boolean))];
      
      // Ê®©Âà©Êúà„ÇíÂèñÂæó
      const rightsMonths = [...new Set(benefits.map(b => b.ex_rights_month).filter(Boolean))];
      
      // Èï∑Êúü‰øùÊúâÂà∂Â∫¶„ÅÆÊúâÁÑ°
      const hasLongTermHolding = benefits.some(b => b.has_long_term_holding === 1);
      
      // RSI„Éá„Éº„Çø
      const rsi = rsiData[stock.code] || { rsi14: null, rsi28: null, stats14: null, stats28: null };
      
      return {
        code: stock.code,
        name: stock.display_name || stock.name,
        originalName: stock.name,
        japaneseName: stock.japanese_name,
        market: stock.market,
        industry: stock.industry,
        price: stock.price || 0,
        dividendYield: yields.dividendYield,
        benefitYield: yields.benefitYield,
        totalYield: yields.totalYield,
        benefitCount: benefits.length,
        benefitGenres,
        rightsMonths,
        hasLongTermHolding,
        minShares: benefits.length > 0 ? Math.min(...benefits.map(b => b.min_shares || 100)) : 100,
        shareholderBenefits: benefits,
        annualDividend: stock.annual_dividend || 0,
        dataSource: stock.data_source || 'unknown',
        rsi14: stock.rsi || rsi.rsi14,
        rsi28: stock.rsi28 || rsi.rsi28,
        rsi14Stats: rsi.stats14,
        rsi28Stats: rsi.stats28
      };
    }));
    
    // „Éï„Ç£„É´„Çø„ÉºÂá¶ÁêÜ
    if (benefitType && benefitType !== 'all') {
      stocksWithDetails = stocksWithDetails.filter(stock => 
        stock.benefitGenres.includes(benefitType)
      );
    }
    
    if (rightsMonth && rightsMonth !== 'all') {
      const month = parseInt(rightsMonth);
      stocksWithDetails = stocksWithDetails.filter(stock => 
        stock.rightsMonths.includes(month)
      );
    }
    
    // RSI„Éï„Ç£„É´„Çø„Éº
    if (rsiFilter && rsiFilter !== 'all') {
      stocksWithDetails = stocksWithDetails.filter(stock => {
        const rsi14 = stock.rsi14;
        if (rsi14 === null || rsi14 === undefined) return false;
        
        switch (rsiFilter) {
          case 'oversold': // Â£≤„Çâ„Çå„Åô„ÅéÔºàRSI < 30Ôºâ
            return rsi14 < 30;
          case 'overbought': // Ë≤∑„Çè„Çå„Åô„ÅéÔºàRSI > 70Ôºâ
            return rsi14 > 70;
          case 'neutral': // ÈÅ©Ê≠£Ôºà30 <= RSI <= 70Ôºâ
            return rsi14 >= 30 && rsi14 <= 70;
          default:
            return true;
        }
      });
    }
    
    // Èï∑Êúü‰øùÊúâÂà∂Â∫¶„Éï„Ç£„É´„Çø„Éº
    if (longTermHolding && longTermHolding !== 'all') {
      if (longTermHolding === 'yes') {
        stocksWithDetails = stocksWithDetails.filter(stock => stock.hasLongTermHolding);
      } else if (longTermHolding === 'no') {
        stocksWithDetails = stocksWithDetails.filter(stock => !stock.hasLongTermHolding);
      }
    }
    
    // „ÇΩ„Éº„ÉàÂá¶ÁêÜ
    stocksWithDetails.sort((a, b) => {
      let aValue, bValue;
      
      switch (sortBy) {
        case 'dividendYield':
          aValue = a.dividendYield;
          bValue = b.dividendYield;
          break;
        case 'benefitYield':
          aValue = a.benefitYield;
          bValue = b.benefitYield;
          break;
        case 'totalYield':
          aValue = a.totalYield;
          bValue = b.totalYield;
          break;
        case 'price':
          aValue = a.price;
          bValue = b.price;
          break;
        case 'name':
          aValue = a.name;
          bValue = b.name;
          break;
        case 'code':
          aValue = a.code;
          bValue = b.code;
          break;
        case 'rsi14':
          aValue = a.rsi14 !== null ? a.rsi14 : (sortOrder === 'asc' ? 100 : -1);
          bValue = b.rsi14 !== null ? b.rsi14 : (sortOrder === 'asc' ? 100 : -1);
          break;
        case 'rsi28':
          aValue = a.rsi28 !== null ? a.rsi28 : (sortOrder === 'asc' ? 100 : -1);
          bValue = b.rsi28 !== null ? b.rsi28 : (sortOrder === 'asc' ? 100 : -1);
          break;
        default:
          aValue = a.totalYield;
          bValue = b.totalYield;
      }
      
      if (typeof aValue === 'string') {
        return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
      } else {
        return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
      }
    });
    
    res.json(stocksWithDetails);
  } catch (error) {
    console.error('Error fetching stocks:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ÂÄãÂà•ÈäòÊüÑË©≥Á¥∞ÂèñÂæó
app.get('/api/stocks/:code', async (req, res) => {
  try {
    const { code } = req.params;
    const stocks = await db.getStocksWithBenefits(code);
    
    if (stocks.length === 0) {
      return res.status(404).json({ error: 'Stock not found' });
    }
    
    const stock = stocks[0];
    const benefits = await db.getBenefitsByStockCode(code);
    
    // ÊúÄÊñ∞„ÅÆÊ†™‰æ°„ÇíÂèñÂæó
    try {
      const latestPrice = await yahooFinance.getStockPrice(code);
      await db.insertPriceHistory(latestPrice);
      stock.price = latestPrice.price;
      stock.dividend_yield = latestPrice.dividendYield;
    } catch (error) {
      console.error('Error updating price:', error);
    }
    
    const yields = calculateYields(stock, benefits);
    
    res.json({
      ...stock,
      dividendYield: yields.dividendYield,
      benefitYield: yields.benefitYield,
      totalYield: yields.totalYield,
      shareholderBenefits: benefits
    });
  } catch (error) {
    console.error('Error fetching stock details:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Ê†™‰æ°Êõ¥Êñ∞
app.post('/api/stocks/:code/update-price', async (req, res) => {
  try {
    const { code } = req.params;
    const stockPrice = await yahooFinance.getStockPrice(code);
    await db.insertPriceHistory(stockPrice);
    res.json(stockPrice);
  } catch (error) {
    console.error('Error updating price:', error);
    res.status(500).json({ error: 'Failed to update price' });
  }
});

// ÂÑ™ÂæÖÊÉÖÂ†±„ÅÆËøΩÂä†/Êõ¥Êñ∞
app.post('/api/stocks/:code/benefits', async (req, res) => {
  try {
    const { code } = req.params;
    const benefit = {
      stockCode: code,
      ...req.body
    };
    
    await db.insertBenefit(benefit);
    res.json({ success: true });
  } catch (error) {
    console.error('Error adding benefit:', error);
    res.status(500).json({ error: 'Failed to add benefit' });
  }
});

// ÂÑ™ÂæÖ„Ç∏„É£„É≥„É´‰∏ÄË¶ßÂèñÂæóÔºàÊîπÂñÑÁâàÔºâ
app.get('/api/benefit-types', async (req, res) => {
  try {
    // „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„ÇâÂÆüÈöõ„ÅÆÂàÜÈ°û„ÇíÂèñÂæó
    const actualTypes = await new Promise((resolve, reject) => {
      db.db.all(`
        SELECT benefit_type, COUNT(*) as count 
        FROM shareholder_benefits 
        WHERE benefit_type IS NOT NULL 
        GROUP BY benefit_type 
        ORDER BY count DESC
      `, (err, rows) => {
        if (err) reject(err);
        else resolve(rows.map(row => row.benefit_type));
      });
    });
    
    res.json(actualTypes);
  } catch (error) {
    console.error('Error fetching benefit types:', error);
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    const fallbackTypes = [
      'È£ü‰∫ãÂà∏„Éª„Ç∞„É´„É°Âà∏', 'ÂïÜÂìÅÂà∏„Éª„ÇÆ„Éï„Éà„Ç´„Éº„Éâ', 'QUO„Ç´„Éº„Éâ„ÉªÂõ≥Êõ∏„Ç´„Éº„Éâ',
      'Ââ≤ÂºïÂà∏„ÉªÂÑ™ÂæÖÂà∏', 'Ëá™Á§æË£ΩÂìÅ„ÉªÂïÜÂìÅ', '„Ç´„Çø„É≠„Ç∞„ÇÆ„Éï„Éà', '„Éù„Ç§„É≥„Éà„ÉªÈõªÂ≠ê„Éû„Éç„Éº',
      'ÂÆøÊ≥ä„Éª„É¨„Ç∏„É£„Éº', '‰∫§ÈÄö„Éª‰πóËªäÂà∏', 'ÈáëÂà∏„ÉªÁèæÈáë', 'ÂØÑ‰ªòÈÅ∏ÊäûÂà∂', 'ÁæéÂÆπ„ÉªÂÅ•Â∫∑',
      'Êú¨„ÉªÈõëË™å„Éª„Ç®„É≥„Çø„É°', '„Åù„ÅÆ‰ªñ'
    ];
    res.json(fallbackTypes);
  }
});

// Ê®©Âà©Êúà‰∏ÄË¶ßÂèñÂæóÔºà1-12ÊúàÂõ∫ÂÆöÔºâ
app.get('/api/rights-months', async (req, res) => {
  try {
    // 1-12Êúà„ÅÆÂõ∫ÂÆö„É™„Çπ„Éà„ÇíËøî„Åô
    const rightsMonths = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    res.json(rightsMonths);
  } catch (error) {
    console.error('Error fetching rights months:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// „Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
app.post('/api/cache/clear', (req, res) => {
  stockCache.clear();
  console.log('üßΩ „Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü');
  res.json({ message: '„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü' });
});

// „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
app.get('/api/health', (req, res) => {
  const healthStatus = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    database: 'connected',
    version: '2.2.0'
  };
  
  // „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂öÁ¢∫Ë™ç
  db.db.get('SELECT COUNT(*) as count FROM stocks', [], (err) => {
    if (err) {
      healthStatus.database = 'error';
      healthStatus.status = 'unhealthy';
      res.status(503).json(healthStatus);
    } else {
      res.json(healthStatus);
    }
  });
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});